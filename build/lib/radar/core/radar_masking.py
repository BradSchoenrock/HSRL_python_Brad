import lg_base.core.array_utils as hau
import numpy as np
import lg_base.core.bit_ops as bo
import hsrl.filters.savitzky_golay as sg
import copy

# Try to use the much faster nanmean from bottleneck, otherwise fall back
# to the scipy.stats version
try:
    from bottleneck import nanmean,nansum,anynan
except ImportError:
    print
    print 'No bottleneck.nanmean available! Falling back to SLOW scipy.stats.nanmean'
    print
    from scipy.stats import nanmean
    from numpy import nansum
    def anynan(x):
        return np.any(np.isnan(x)) 

def radar_masking(rs_radar,processing_defaults,instrument):
    """radar_masking(rs_radar,processing_defaults)
       rs_radar = structure generated by radar processing stream
       processing_defaults = config info from 'radar_processing_defaults.json'
       qc_radar_mask, bit[0] = longical and of all other bits
       qc_radar_mask, bit[1] = cleared if radar refectivity fall below SNR threshhold
       """
   
    assert(rs_radar!=None)
    if not hasattr(rs_radar,'Backscatter'):
        return rs_radar

    threshhold = processing_defaults.get_value('radar_SNR_mask','threshhold')
    #radar mask ok when sig_to_noise greater than threshhold in dB
    rs_radar=copy.copy(rs_radar)
    #fix me this has been changed to a single bit because the interpolator is
    #not aware of summode
    rs_radar.qc_radar_mask = \
        hau.TZ_Array(np.ones(rs_radar.Backscatter.shape),summode='or',dtype='uint16')
          #rs_radar.qc_radar_mask[:,:]=65535
      #mask = np.ones_like(rs_radar.Backscatter)
      #mask[rs_radar.SignalToNoiseRatio < threshhold] = 0
          #mask = ~(3*mask.astype('uint16'))
      #rs_radar.qc_radar_mask &= mask

    rs_radar.qc_radar_mask[rs_radar.SignalToNoiseRatio < threshhold] = 0
    rs_radar.qc_radar_mask[np.isnan(rs_radar.SignalToNoiseRatio)] = 0
  
    
    print
    print 'instrument', instrument
       
    if (instrument == 'magkazrge' or 'magmwacr') \
                and processing_defaults.enabled('ship_motion_correction'):
            temp = rs_radar.MeanDopplerVelocity.copy()
            temp[rs_radar.qc_radar_mask == 0] = np.NaN
            rs_radar.vertically_averaged_doppler =hau.T_Array(nanmean(temp,1))

    return rs_radar

         



def radar_postprocessing(rs_radar,processing_defaults,instrument):
    assert(rs_radar!=None)
    if processing_defaults.enabled('ship_motion_correction') and hasattr(rs_radar,'vertically_averaged_doppler'):
        print 'ship motion correction applied'
        rs_radar=copy.copy(rs_radar)
        rs_radar.MeanDopplerVelocity=copy.deepcopy(rs_radar.MeanDopplerVelocity)
        if 0:
            import matplotlib.pylab as plt
            plt.figure(3000)
            x_vec = np.arange(len(rs_radar.vertically_averaged_doppler))
            plt.plot(x_vec,-rs_radar.vertically_averaged_doppler \
                ,x_vec,rs_radar.MeanDopplerVelocity[:,[25,50,100]]-1.0,'r')
            plt.grid(True)

        
        motion_correction = np.transpose(rs_radar.vertically_averaged_doppler\
                                    *np.transpose(np.ones_like(rs_radar.MeanDopplerVelocity))) 
        rs_radar.MeanDopplerVelocity -= motion_correction
        if 0:
            plt.figure(3001)
            plt.plot(x_vec,rs_radar.vertically_averaged_doppler
                ,x_vec,rs_radar.MeanDopplerVelocity[:,100])
            plt.grid(True)
    return rs_radar

     
     
             
